<!DOCTYPE html>
<html lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8"><meta name="generator" content="Hugo 0.133.0"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>leetcode笔记&nbsp;&ndash;&nbsp;santiweide&#39;s Blog</title><link rel="stylesheet" href="/css/core.min.003a667cf21024ef30f2985fb57c9bd6f6873cf899ee14e9302e68e9f04b681df9440cec4ebdaa101dca533a262c242f.css" integrity="sha384-ADpmfPIQJO8w8phftXyb1vaHPPiZ7hTpMC5o6fBLaB35RAzsTr2qEB3KUzomLCQv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="leetcode笔记" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">santiweide's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="/friend">友链</a><a class="nav item" href="https://gohugo%2eio/"target="_blank" rel="noopener noreferrer">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">露の世は露の世ながらさりながら</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">leetcode笔记</h1><p class="article date">Tuesday, May 18, 2021</p></section><article class="article markdown-body"><h2 id="节奏">节奏</h2>
<pre tabindex="0"><code>5.28 数组					done
5.29 链表done				done but没写707设计链表
5.30 hashmap 				done
5.30 字符串					done but kmp
5.31 kmp					done but no code
	 双指针都写过了			done
	 栈和队列				done but 还没写deque和priority queue
6.1  deq &amp; priq				done
	 二叉树					遍历，翻转
6.2	 二叉树					最大最小深度，是不是平衡二叉树
6.3  二叉树					所有路径，对称，Same，最左下角值，构造二叉树（经典笔试题目...），合并两个二叉树，二叉搜索树中序遍历递增判别
							二叉搜索树最小绝对差（也是利用中序遍历有序）
							二叉搜索树众数
							公共祖先：一般树 &amp; 二叉搜索树
							二叉搜索树插入 &amp; 删除（合理的删除很多！不要纠结平衡...
							修建数组（随便递归递归
							构造搜索树 建立索引
							累加树 中序遍历
6.4  回溯					组合求和 上下界都可以优化~
							电话号码组合 万变不离其宗
							分割回文字符串
							复原ip地址
							子集：若只要叶子的话，如何去重复 || 不如直接构造整个树~
							重复子集：注意剪枝
							递增子序列 同层同val不复搜
							全排列 vector版本和bool版本~
6.5	回溯					全排列去重 注意递归条件呀，还有循环从0开始一般需要check used数组
6.6 贪心					重新安排行程 靠着map的有序性，保证第一个答案就是最终答案，提前剪枝~
							TODO ：N皇后，解数独
							分饼干 排序移动模拟
							摆动序列(做成了dp) or 贪心统计peek的数量~
							最大子数组和 见负就收，因为负的sum只会take down
6.7	贪心					买卖股票 贪每个最大上升距离心（局部最优是每天正利润）
							跳跃游戏  贪每次最远心 每次都试探范围内所有可以跳过去的地方
							跳跃游戏2 简而言之，最小扩大几次可以触达边界。
							K次取反后最大化的数组和 注意k的循环性；两次贪心~
							加油站  case全局视角，1.关注总量 2.关注余量
									case局部视角，如果当前i地方的s不够了，start就是i+1
6.8	贪心					分糖果 TODO 贪心 尽可能给相邻低分分配更少的糖果
										数学抽象：一个curve，让它更低 但是保持两两相邻位置大小关系
										策略：默认1，从左向右发一遍糖果，再从右向左发一遍糖果（max）
							柠檬水	贪心多用10，毕竟只有这块能用10
							根据身高重建队列 我理解是一道模拟题（逃
							用最少数量的箭引爆气球 一看就是笔试题的风格（。排序之后根据集合的交集射箭，如果两个集合有交集就只留下交集，最后剩下多少个交集答案就是多少了。不写了。记一个TODO好了 https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
							无重叠区间 l坐标从小到大排序，发现重叠去掉R大的 TODO
							划分字母区间 把字符串分成尽可能多的若干部分，这若干部分的字符集合没有交集
										最多每个字符都是一个集合，但是只有没有重复字符的时候才能这么搞
										考虑有一个字符出现2次，出现的2次下标[i,j]一定要被一个cover
										可以把同一个字母出现的下标[a0,a1,...,an-1]转化为[a0,an-1]这个区间
										于是就变成了一连串区间（最多26个）[[a0,...,an-1], [b0,...,bn-1],...[z0,...zn-1]]
										合并规则：合并到没有交集 TODO
6.9	DP						斐波那契 &amp; 爬楼梯 &amp; cost爬楼
							合并区间 按照l排序，对每个l合并r，下一个l2一定大于r1不然会被合并 TODO
	二分					在排序数组中查找元素的第一个和最后一个位置 # 按照大小关系二分~~直接二分左右边界还是优越啊~
							搜索插入位置，最后一定要分类讨论思考一下呀~~~多写写多写写
							
6.10
	TODO设计（明儿想想）		LRU Cache 
								case 不带模板
								case 带模板
	DP						不同路径 &amp; 不同路径2
6.11
	DP						整数拆分 递归
							不同的二叉搜索树 递归
	贪心					单调递增的数字 可恶思路明明一样为啥我写出来是个这！ans：因为我理解的单调递增不带等号=。=
							买卖股票的最佳时机含手续费
								没有手续费的时候，单天利润&gt;0就可以买；有手续费的时候就是带上手续费&gt;0可以买
								想到一句话：循环不变
6.13
	DP						打家劫舍
							打家劫舍：围成一圈
							打家劫舍：二叉树上
									看到二叉树一定要先考虑递归~然后有重复计算超时了：P加个map记忆化一下：P
	DP						股票 一次 ： 记录当前最小值
								若干次：正的就买
								两次：当前交易状态 0 1 2 3 4
								k次：当前交易次数 0 ... k
								冷静期 + 随意次数交易：确定状态是最重要的，买入，非刚卖出，刚卖出，冷冻期
								手续费 + 随意交易次数：当前有股票，当前没有股票
6.14
	DP						背包
								分割相等和的子集
								最小石头重量
									尽可能把石头分成重量一样的两堆
							最长上升子序列
6.15
	DP					目标和 dp[和] = 方案数
							假设x个数字加起来了，剩下减号后面的数字是-(sum-x)。于是target = x - sum + x, x = (target + sum) / 2
							dp[x] = ans
							dp[j] += dp[j - nums[i]] 
						一和零
							多了一个维度的背包
							（往往自己刷题很容易想到思路吧，真的到了比赛的时候可能就紧张张大暴力）
6.16	设计题			LRU Cache~
6.17	单调栈			每日温度
6.18	单调栈			下一个更大元素1
							昨晚像这道题的时候在床上自恋到睡不着= =
						下一个更大元素2
							跳表！想到这点之后自恋地在床上睡不着觉
								但是没有料到有重复元素= =
		杂				接雨水
							不要局限单调栈！思路对了才是最重要的！
							虽然也可以用单调栈来做啦...来我们看看
6.19					单调栈接雨水
		找出任意重复数字
						1 在意O(n)时间，选用map
						2 在意空间的话，排序
							各种排序算法的时间空间复杂度，可能·写一波代码会熟悉一些
						3 如果0-n-1的数字一定都出现了，总共n+1个数字，可以鸽巢 需要每个数字至少出现一次
6.20	03 				重复出现的数字系列（TODO 整理一下整个系列，都写一下）
		06				花式倒着处理链表系列，要么递归要么三指针原地反转~
6.21					旋转列表最小值
							细细分析~别太复杂
6.22					删除链表节点
							链表和树一定要考虑递归！！
						奇数再偶数前面
							双指针~
6.23					倒数第k个结点
							双指针
						树的子结构
							记得判断一下..可以化简状态！
6.24					1+...+n
							骤死评估 n &amp;&amp; res += sum(n-1)
6.25					复杂链表复制
							直接写：时间空间都还不错
							哈希：map[cur] = new Node 代码最短~
							原地修改法：p-&gt;next = (p)&#39; p-&gt;random-&gt;next = (p-&gt;random)&#39; 优美。
6.26					合法的pop push
							use stack 直接模拟
							not use stack 指针模拟 top
						和为s的连续数字，不要陷入数学！从程序的角度考虑！
							TODO function作为函数参数怎么写
							 额，用数学枚举了，为啥能二分啊？？
6.27				一次循环搞定第一个只出现一次的char！LRU cacheyyds
					数组中2个数字只出现过一次，用a^b分类~
					数字中出了一个出现一次其他都出现3次，这样出现3次的二进制位之和一定可以被3整除，余下的就是那个了
						可以不用数组吗？
							可以！设计一种逻辑就可以！
6.30			dp 剪绳子 2 3
				TODO 快速排序
				TODO 正则表达式
				排成最小的数字 a+b&lt;b+a好难想！！
					巧妙地排序条件=w=
7.6			摩尔投票法，出现最多的数字
				从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个

7.7			寻找重复数字系列
				* 可以修改数组 利用value &gt; 0，让哈希和nums本身二合一 为啥非要加abs呢？因为会变负数呀~~
				* 不能修改数组 双指针
				
				
				两数之和 == k 两数之差 == k
				
7.20 		树上前缀和，妙啊！
</code></pre><p>不過問題從演算法開始，問了 Heap 跟 Hash Table 的問題，還問了一些 Hash function 的細節。
二分
LRU Cache
race condition 上lock或者看看怎么从业务逻辑避免</p>
<p>算法题目：</p>
<ol>
<li>矩阵乘法</li>
<li>链表归并排序</li>
<li>有序的数组（正负都有），返回每项取平方的排序结果</li>
<li>被問 heapq 是什麼，具體怎麼操作</li>
</ol>
<ul>
<li>問 hash set 怎麼實作怎麼處理 collision 細節 (probing, self balanced binary search tree)</li>
</ul>
<ol start="5">
<li>coding，都是 medium 程度的變形</li>
</ol>
<ul>
<li>array 找所有的 triplet 的 sum 使得他們的 sum 是 k 的倍數
像解釋 rehash 機制，能不能做得更快</li>
</ul>
<p>input: [(&lsquo;a&rsquo;, &lsquo;b&rsquo;), (&lsquo;c&rsquo;, &rsquo;d&rsquo;), (&lsquo;b&rsquo;, &rsquo;e&rsquo;)]
output: [[&lsquo;a&rsquo;, &lsquo;b&rsquo;, &rsquo;e&rsquo;], [&lsquo;c&rsquo;, &rsquo;d&rsquo;]]
找出同一個 group，且 output 是要 follow input 的 order e.g., a &gt; b &gt; e</p>
<p>二分 &amp; 动态规划是重点
项目也好好准备
<a href="https://github.com/donnemartin/system-design-primer"target="_blank" rel="noopener noreferrer"></a>
**系统设计项目
**印度老外讲的系统设计听听
<a href="https://www.youtube.com/watch?v=umWABit-wbk"target="_blank" rel="noopener noreferrer">uber system design - Tech Dummies Narendra L</a></p>
<p>回溯
贪心
动态规划
背包 &amp; 打家劫舍
股票
子序列
单调栈
补充题目</p>
<h2 id="top题单">TOP题单</h2>
<h3 id="两数之和">两数之和</h3>
<p>case 俩循环
就是On^2嘛</p>
<p>case 用一个map替代内循环
纯纯的空间换时间</p>
<p>case 不用返回数组下标：排序之后双指针
排序，随着i增大,nums[i]增大,target - nums[i]减小，欲使nums[j] == target - nums[i]需要j更小。</p>
<p>其他
复习下构造函数
** 拷贝构造函数，赋值构造函数，move构造函数，vector初始化复制</p>
<pre tabindex="0"><code>vector&lt;int&gt; a = {1, 2, 3, 4};
vector&lt;int&gt; b(a); //
vector&lt;int&gt; b = std::move(a); // 
vector&lt;int&gt; b = a; // 
</code></pre><h3 id="两数相加">两数相加</h3>
<p>case 不递归
写一个超工整的linked list就好啦，记得进位~</p>
<p>case 递归
所有链表和树第一想法是递归准没错XD 挺好写的</p>
<p>** struct在成员里面赋值，和在构造函数里面赋值的区别？（顺序？）
** struct成员变量的内存排布？</p>
<h3 id="无重复字符最长子串">无重复字符最长子串</h3>
<p>case 时间O(n)
纯纯的滑动窗口，unordered_map记录一下出现次数就好</p>
<p>case 别的写法
what if unorder_map记录的是上一次出现的位置？依然维护头尾两个指针，每次更新j之后，直接从map拿下一个i。</p>
<p>** std::map线程安全吗？std::unorder_map呢？</p>
<p>（std标准库里面的数据结构应该都是并发读安全，一旦参合了并发写就不安全了。）</p>
<h3 id="正序数组中位数">正序数组中位数</h3>
<p>case 两个数组里二分
ans要求是两个数组merge之后的(l1+l2)/2位置（odd length）或者(l1+l2)/2-1 和(l1+l2)/2的平均
那我们需要找到这俩位置的数字就好，也就是说，找到第 k 大的数字, where k = (l1+l2)/2-1</p>
<p>嗯，很归并排序。</p>
<h4 id="相似的题目">相似的题目</h4>
<ul>
<li>
<p>合并两个有序链表：双指针merge，完全一致</p>
</li>
<li>
<p>删除有序数组中的重复项目：双指针，答案指针+遍历指针，这个角度是一致的。</p>
</li>
<li>
<p>有序数组的平方：平方完了有序，那一定是按照绝对值排序。这样的话，原来的数组找到正负交界，俩指针动push就好。完全一致</p>
</li>
</ul>
<h3 id="最长回文子串">最长回文子串</h3>
<p>case 枚举答案
枚举长度是奇数和偶数；每轮只要能够造出来对应的序号就行
On^2 时间，O1空间（不过我额外空间用来存答案，可以换成存i,j 下标）</p>
<p>case 动态规划
dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]</p>
<h3 id="整数反转">整数反转</h3>
<p>紧巴巴的日子</p>
<h3 id="有效的括号">有效的括号</h3>
<p>case stack
直接写</p>
<h3 id="最长公共前缀">最长公共前缀</h3>
<p>求交集，找一个包含答案的str，记录end pos，循环缩短就好</p>
<h3 id="加一">加一</h3>
<p>直接模拟</p>
<p>** vector append vector
a.insert(a.end(), b.begin(), b.end())</p>
<h2 id="摆烂了随便写的题">摆烂了，随便写的题</h2>
<h3 id="长度最小的子数组">长度最小的子数组</h3>
<p>case 滑动窗口
满足ooxx条件的长度最小/最大的aabb，纯纯的滑动窗口嘛！</p>
<h3 id="螺线矩阵ii">螺线矩阵II</h3>
<p>这题个人理解就是看思路清晰就好，代码题。注意边界条件就好。</p>
<p>（说起来pdd三面还问了我这个，：P）</p>
<ul>
<li>vector初始化的n是resize效果还是reserve效果？ans：resize效果，甚至还可以赋值初始值。</li>
</ul>
<h3 id="反转链表">反转链表</h3>
<p>case 双指针
纸上推算即可</p>
<p>case 递归
不断抽象可以写很短</p>
<h3 id="删除链表倒数第n个结点">删除链表倒数第n个结点</h3>
<p>case 递归
如果链表有记录当前结点到尾巴的长度的话，会比较好写</p>
<p>case 循环
俩指针保持距离向前走</p>
<h3 id="找俩链表的交点">找俩链表的交点</h3>
<p>case 长度差：距离交点距离一样的节点，到交点需要同样多步。
O(m+n)</p>
<p>case 双指针循环移动
pA: a + l + b + l
pB: b + l + a + l
|——————meet up
O(m + n)</p>
<h3 id="环形链表2">环形链表2</h3>
<p>自己环自己，找到入口。如何定义入口？从head开始走，第一个进入环的node就是入口</p>
<p>case 指针
第一次相遇，第二次相遇</p>
<h3 id="有效的字母异位词">有效的字母异位词</h3>
<p>操控放给被操控方，情感操控
不允许和别的女生玩，只能有一个朋友；与别人正常相处有负罪感
切断关系，过程拉锯战，斗争</p>
<h3 id="1002-查找常用字符串">1002 查找常用字符串</h3>
<p>keys + min{ocr_map[i]} if != 0 then &raquo; ans</p>
<h3 id="305-两个数组的交集2">305 两个数组的交集2</h3>
<p>case 双指针</p>
<p>case set
先求出来交集，然后ret里面放x个交集元素，x为nums1和nums2出现次数的最小值。</p>
<h3 id="202-快乐数">202 快乐数</h3>
<p>case 缓存hashmap</p>
<h3 id="四数相加">四数相加</h3>
<p>不用去掉重复 &amp; 只在意多少个而不是pos的话，可以大哈希。</p>
<p>case 四个循环</p>
<p>case 两个循环+1个unordered_map（大哈希a*b的(ai+bi):ocr）（best ans, On^2）
&ndash; 传说中的降维打击</p>
<p>case 2个循环+二分找a+b构造的新数组</p>
<p>case sort之后四个指针</p>
<h3 id="383-赎金信">383 赎金信</h3>
<p>降维打击成为词典
另外用map前要是能用数组就用数组吧</p>
<h3 id="15-三数之和">15 三数之和</h3>
<p>所有和为0的不重复三元组</p>
<p>case 两个循环+二分
时间复杂度n^2logn</p>
<p>case sort之后循环 + 双指针
注意去重</p>
<h3 id="18-四数之和">18 四数之和</h3>
<p>case sort 之后循环 + 双指针</p>
<h3 id="541--反转字符串2">541  反转字符串2</h3>
<p>模拟</p>
<h3 id="替换空格">替换空格</h3>
<p>case 双指针
不用额外空间；预留填充后的大小，然后从后向前填充</p>
<h3 id="151-反转字符串">151 反转字符串</h3>
<p>case 开坑模拟
reserve就是耗时的精髓&hellip;内存分配耗时szd长</p>
<p>case 反转整个然后每个单词反转也行 TODO
好处就是原地的节省内存。
精细的内存操作&hellip;</p>
<h3 id="剑指offer2-58-左旋转字符串">剑指offer2-58 左旋转字符串</h3>
<p>case 额外空间n
case 不用额外空间，只是reverse</p>
<h3 id="28-实现strstr">28. 实现strstr</h3>
<p><a href="https://leetcode-cn.com/problems/implement-strstr/"target="_blank" rel="noopener noreferrer">有空补上咯</a></p>
<ul>
<li>kmp
next数组含义：描述了tobe匹配的字符串的特征，这个特征值的是“以当前位置为len的最长前后缀长度”</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span>
</span></span><span class="line"><span class="cl">a a a b a a f
</span></span><span class="line"><span class="cl"><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">0</span>
</span></span></code></pre></div><p>在strstr的时候，next的用法：如果[i]不能匹配，就回退[i-1]的前缀表这么多，然后继续匹配
也就是说，sub[i - next[i - 1]] 就是能保证可能匹配的下一个最近状态了。</p>
<p>实际上kmp也算是一个状态转移的记录表吧。</p>
<p>比如匹配到sub[6] != master[x], 对sub转移到sub[2],保证了master[x-2][x-1]和sub[0][1]是一样的，省去了多余的移动过程</p>
<h3 id="重复的子字符串">重复的子字符串</h3>
<p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/"target="_blank" rel="noopener noreferrer">有空补上咯</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span> <span class="m">9</span> <span class="m">10</span> <span class="m">11</span>
</span></span><span class="line"><span class="cl">a b c a b c a b c a b c
</span></span><span class="line"><span class="cl"><span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span> <span class="m">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">重复长度</span> <span class="o">=</span> <span class="m">12</span> - <span class="nv">9</span> <span class="o">=</span> <span class="m">3</span>
</span></span></code></pre></div><h3 id="栈实现队列">栈实现队列</h3>
<p>case 一个stack仅仅是buffer</p>
<p>case 两个stack腾挪
“延迟配送”，sIn &amp; sOut。进了Out就是走上了一条不归路&hellip;
注意代码复用</p>
<h3 id="有效括号">有效括号</h3>
<p>case模拟</p>
<h3 id="1047-删除字符串中的所有相邻重复项">1047 删除字符串中的所有相邻重复项</h3>
<p>匹配问题都是栈的强项~~</p>
<p>但是用stack还是不方便呀，投奔双指针=w=</p>
<h3 id="逆波兰表达式求值">逆波兰表达式求值</h3>
<p>和1047差不多，先不写。
<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/"target="_blank" rel="noopener noreferrer">有空补上咯</a></p>
<h3 id="239-滑动窗口最大值">239. 滑动窗口最大值</h3>
<p>case 双向队列维护一个滑动窗口</p>
<p>这个队列可以抽象成双指针就是。
但是，如果想维护一个内容和原来不一样的队列，就不如直接用队列。</p>
<p>想提升性能，就自己写一个数组指针吧~</p>
<h3 id="347-前-k-个高频元素">347. 前 K 个高频元素</h3>
<p>case 优先队列
小顶堆</p>
<p>** priority queue 的cmp咋写
关于大小比较，优先级队列的定义正好反过来了。cmp我们这里写的是大于号，但是效果是小顶堆</p>
<p>** 堆的定义</p>
<p>** 堆排序以及它的细节</p>
<p>case 快速排序选前k大</p>
<h3 id="二叉树">二叉树</h3>
<ul>
<li>c++中map，set，multimap，multiset都是平衡二叉搜索树
TODO 前中后序遍历 非递归实现</li>
</ul>
<h4 id="从下往上层次遍历">从下往上层次遍历</h4>
<p>reverse从上往下大法好
（根据答案构造）</p>
<h4 id="117-填充每个节点的下一个右侧节点指针">117. 填充每个节点的下一个右侧节点指针</h4>
<p>case 层序遍历</p>
<p>case 木偶
在n-1层操作第n层的next指针，从第一层开始（next齐全）
TODO</p>
<h4 id="111-二叉树的最小深度">111 二叉树的最小深度</h4>
<p>多拆开一层就好</p>
<h4 id="完全二叉树的结点个数">完全二叉树的结点个数</h4>
<p>利用满二叉树性质计算</p>
<h4 id="257-所有路径">257 所有路径</h4>
<p>深搜就行</p>
<h4 id="lru-cache">LRU Cache</h4>
<p>还是很喜欢长链接的实现的~双向循环链表fake结点实现 + hashmap key和Node冗余存储简化查找&amp;更新 + 提前分配内存节约内存
学习了！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LRUCache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">_tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">_entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">_free_entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;</span> <span class="n">_map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">detach</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// remove from linked list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">attach</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add to head
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">_head</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_entries</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">_free_entries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">_entries</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">_tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">_head</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">_tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_tail</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_head</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">_tail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_tail</span> <span class="o">-&gt;</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">detach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">attach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">detach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">attach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">_free_entries</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// full, remove from tail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">node</span> <span class="o">=</span> <span class="n">_tail</span> <span class="o">-&gt;</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">_map</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">detach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>       
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">node</span> <span class="o">=</span> <span class="n">_free_entries</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">_free_entries</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">attach</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Your LRUCache object will be instantiated and called as such:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * LRUCache* obj = new LRUCache(capacity);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * int param_1 = obj-&gt;get(key);
</span></span></span><span class="line"><span class="cl"><span class="cm"> * obj-&gt;put(key,value);
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span></code></pre></div></article>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/interview_review/"><span class="iconfont icon-article"></span>零碎备忘</a></p><p><a class="link" href="/post/basic_knows/"><span class="iconfont icon-article"></span>备忘</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 Notepadium.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div></section>
  

</body>

</html>